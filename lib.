import 'dart:developer';
import 'dart:io';

import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:flutter/services.dart';
import 'package:flutter_blue_plus/flutter_blue_plus.dart';
import 'package:flutter_esc_pos_network/flutter_esc_pos_network.dart';
import 'package:image/image.dart' as img;
import 'package:za_blue_printer/models/blue_device.dart';
import 'package:za_blue_printer/models/connection_status.dart';
import 'package:za_blue_printer/receipt/receipt_section_text.dart';
import 'package:za_blue_printer/scanner/blue_scanner.dart';

import 'za_blue_printer_platform_interface.dart';
import 'package:blue_thermal_printer/blue_thermal_printer.dart' as blue_thermal;
import 'package:flutter_blue_plus/flutter_blue_plus.dart' as flutter_blue;
import 'label_printer/label_printer_manager.dart';

/// Printer type enumeration for automatic command generation
///
/// The package automatically detects printer type based on device name:
/// - Label printers (GP, TSC, Zebra, etc.) → Uses TSPL/ZPL/CPCL commands
/// - Receipt printers (POS, Epson, etc.) → Uses ESC/POS commands
enum PrinterType {
  escpos, // Receipt printers: ESC/POS (Epson, Star, generic POS printers)
  labelPrinter, // Label printers: Auto-detects TSPL/ZPL/CPCL based on brand
  // Legacy support (deprecated - use labelPrinter instead)
  gp1324d, // GP1324d label printer (deprecated)
  tspl, // TSPL command language (deprecated)
  zpl, // ZPL command language (deprecated)
}

/// Universal Bluetooth Printer Manager
///
/// Supports ALL thermal printers with automatic detection:
///
/// LABEL PRINTERS (auto-detected):
/// - GPrinter: GP1324D, GP1124D, GP2120TF → TSPL
/// - TSC: TTP-244, TTP-247, TE200 → TSPL
/// - Zebra: ZD420, GK420, ZT410 → ZPL
/// - Brother: QL-720NW, QL-810W → CPCL
/// - Godex, POSTEK, Argox → TSPL
///
/// RECEIPT PRINTERS:
/// - Epson: TM-T88V, TM-T88VI → ESC/POS
/// - 58mm/80mm generic POS printers → ESC/POS
///
/// USAGE:
/// ```dart
/// // Auto-detects printer type on connect
/// await printer.connect(device);
///
/// // Print on ANY printer
/// await printer.printLabel(content: 'Hello', barcode: '123');
/// ```
class ZaBluePrinter {
  Future<String?> getPlatformVersion() {
    return ZaBluePrinterPlatform.instance.getPlatformVersion();
  }

  blue_thermal.BlueThermalPrinter? _bluetoothAndroid;
  flutter_blue.BluetoothDevice? _bluetoothDeviceIOS;
  flutter_blue.FlutterBluePlus? _bluetoothIOS;
  static ZaBluePrinter get instance => ZaBluePrinter();
  static const MethodChannel _channel = MethodChannel("blue_print_pos");
  bool _isConnected = false;

  bool get isConnected => _isConnected;

  BlueDevice? selectedDevice;
  PrinterType printerType = PrinterType.escpos;
  LabelPrinterConfig? labelConfig;
  LabelPrinterLanguage? detectedLanguage;
  ZaBluePrinter() {
    _bluetoothAndroid = blue_thermal.BlueThermalPrinter.instance;
  }
  Future<List<BlueDevice>> scan() async {
    return await BlueScanner.scan();
  }

  Future<ConnectionStatus> disconnect({
    Duration timeout = const Duration(seconds: 5),
  }) async {
    if (Platform.isAndroid) {
      if (await _bluetoothAndroid?.isConnected ?? false) {
        await _bluetoothAndroid?.disconnect();
      }
      _isConnected = false;
    } else if (Platform.isIOS) {
      await _bluetoothDeviceIOS?.disconnect();
      _isConnected = false;
    }

    return ConnectionStatus.disconnected;
  }

  Future<ConnectionStatus> connect(
    BlueDevice device, {
    Duration timeout = const Duration(seconds: 5),
  }) async {
    selectedDevice = device;

    // Auto-detect if this is a label printer
    _autoDetectPrinterType(device.name ?? '');
    try {
      if (Platform.isAndroid) {
        final blue_thermal.BluetoothDevice bluetoothDeviceAndroid =
            blue_thermal.BluetoothDevice(selectedDevice?.name ?? '', selectedDevice?.address ?? '');
        if (_bluetoothAndroid != null) {
          await _bluetoothAndroid!.connect(bluetoothDeviceAndroid);
        }
      } else if (Platform.isIOS) {
        _bluetoothDeviceIOS = flutter_blue.BluetoothDevice.fromProto(flutter_blue.BmBluetoothDevice(
            remoteId: DeviceIdentifier(selectedDevice?.address.toString() ?? ' - '),
            platformName: selectedDevice?.name ?? ' - '));

        // remoteId: selectedDevice?.address.toString() ?? ' - ', platformName: selectedDevice?.name ?? ' - '));
        final List<flutter_blue.BluetoothDevice> connectedDevs = flutter_blue.FlutterBluePlus.connectedDevices;
        final int deviceConnectedIndex = connectedDevs.indexWhere((flutter_blue.BluetoothDevice bluetoothDevice) {
          return bluetoothDevice.id == _bluetoothDeviceIOS?.id;
        });
        if (deviceConnectedIndex < 0) {
          await _bluetoothDeviceIOS?.connect();
        }
      }

      _isConnected = true;
      selectedDevice?.connected = true;
      return Future<ConnectionStatus>.value(ConnectionStatus.connected);
    } on Exception catch (error) {
      print('$runtimeType - Error $error');
      _isConnected = false;
      selectedDevice?.connected = false;
      return Future<ConnectionStatus>.value(ConnectionStatus.timeout);
    }
  }

  Future<void> printReceiptTextWireless(ReceiptSectionText receiptSectionText,
      {int feedCount = 0,
      bool useCut = false,
      bool useRaster = false,
      double duration = 0,
      bool byteLog = false,
      required bool is80,
      required String host,
      String? printerDeviceName}) async {
    final Uint8List bytes = await contentToImage(
      content: is80 ? receiptSectionText.content80 : receiptSectionText.content58,
      duration: duration,
    );
    if (byteLog == true) {
      log("contentToImage====> ${bytes}");
    }
    final List<int> byteBuffer = await getbytes(
      bytes,
      paperSize: is80 ? PaperSize.mm80 : PaperSize.mm58,
      feedCount: feedCount,
      useCut: useCut,
      useRaster: useRaster,
      deviceName: printerDeviceName,
    );
    if (byteLog == true) {
      log("printReceiptText====> ${byteBuffer}");
    }

    final printer = PrinterNetworkManager(host);
    PosPrintResult connect = await printer.connect();
    if (connect == PosPrintResult.success) {
      PosPrintResult printing = await printer.printTicket(byteBuffer);

      print(printing.msg);
      printer.disconnect();
      log("wireless => printing finished ");
    }
  }

  Future<String?> printReceiptTextA4A5Wireless(ReceiptSectionText receiptSectionText,
      {int feedCount = 0,
      bool useCut = false,
      bool useRaster = false,
      double duration = 0,
      bool byteLog = false,
      required bool isA4,
      required String host}) async {
    try {
      if (true) {
        final Uint8List bytes = await contentToImage(
          content: isA4 ? receiptSectionText.contentA4 : receiptSectionText.contentA5,
          duration: duration,
        );

        if (byteLog == true) {
          log("contentToImage====> ${bytes}");
        }
        double inch = 72.0;
        double cm = inch / 2.54;
        double mm = inch / 25.4;
        int a4Width = (21.0 * cm).toInt();
        int a5Width = (14.8 * cm).toInt();
        int a4Height = (29.7 * cm).toInt();
        int a5Height = (21.0 * cm).toInt();
        final List<int> byteBuffer = await getbytes(bytes,
            paperSize: isA4 ? PaperSize.mm80 : PaperSize.mm58,
            feedCount: feedCount,
            useCut: useCut,
            useRaster: useRaster,
            isA4: isA4,
            customWidth: isA4 ? a4Width : a5Width);
        if (byteLog == true) {
          log("printReceiptText====> ${byteBuffer}");
        }
        final printer = PrinterNetworkManager(host);
        PosPrintResult connect = await printer.connect(timeout: const Duration(minutes: 2));
        log("connect Status====> ${connect.value}/");
        if (connect == PosPrintResult.success) {
          PosPrintResult printing = await printer.printTicket(byteBuffer);
          print(printing.msg);
          printer.disconnect();
          log("wireless => printing finished ");
          return "printing finished";
        } else {
          for (var i = 0; i < 3; i++) {
            log("connected ==> printer ${connect.value}");
            connect = await printer.connect(timeout: const Duration(minutes: 1));
            if (connect == PosPrintResult.success) {
              PosPrintResult printing = await printer.printTicket(byteBuffer);
              print(printing.msg);
              printer.disconnect();
              log("wireless => printing finished ");
              return "printing finished";
              break;
            } else {
              await Future.delayed(const Duration(seconds: 5));
              log("Re-try => Printer Conneting");
            }
          }
        }
        if (connect != PosPrintResult.success) {
          return "Printer Error : ${connect.msg}";
        }

        // if (connect == PosPrintResult.success) {
        //       PosPrintResult printing = await printer.printTicket(byteBuffer);
        //     print(printing.msg);
        //     printer.disconnect();
        //     log("wireless => printing finished ");
        //   }else{
        //     connect = await printer.connect(timeout: Duration(seconds: 30));
        //    log("connect error ====> ${connect.value}/");
        //   }
      } else {
        log("invoiceByteArray  ==> empty");
        return " receiptSectionText is null";
      }
    } catch (e) {
      log("printer error==> $e");
      return e.toString();
    }
  }

  Future<void> printReceiptText(
    ReceiptSectionText receiptSectionText, {
    int feedCount = 0,
    bool useCut = false,
    bool useRaster = false,
    double duration = 0,
    bool byteLog = false,
    bool? defaultPrintfun = true,
    required bool is80,
    String? printerDeviceName,
  }) async {
    final Uint8List bytes = await contentToImage(
      content: is80 ? receiptSectionText.content80 : receiptSectionText.content58,
      duration: duration,
    );
    if (byteLog == true) {
      log("contentToImage====> ${bytes}");
    }
    final List<int> byteBuffer = await getbytes(
      bytes,
      paperSize: is80 ? PaperSize.mm80 : PaperSize.mm58,
      feedCount: feedCount,
      useCut: useCut,
      useRaster: useRaster,
      deviceName: printerDeviceName,
    );
    if (byteLog == true) {
      log("printReceiptText====> ${byteBuffer}");
    }
    _printProcess(byteBuffer: byteBuffer, byteLog: byteLog, defaultPrintfun: defaultPrintfun);
  }

  Future<void> printReceiptImage(Uint8List bytes,
      {int width = 120,
      int feedCount = 0,
      bool useCut = false,
      bool useRaster = false,
      required PaperSize paperSize,
      bool? byteLog = false,
      bool? defaultPrintfun = true,
      String? printerDeviceName}) async {
    final List<int> byteBuffer = await getbytes(bytes,
        customWidth: width,
        feedCount: feedCount,
        useCut: useCut,
        useRaster: useRaster,
        paperSize: paperSize,
        deviceName: printerDeviceName);
    if (byteLog == true) {
      log("printReceiptImage====> ${byteBuffer}");
    }
    _printProcess(
      byteBuffer: byteBuffer,
      byteLog: byteLog,
      defaultPrintfun: defaultPrintfun,
    );
  }

  Future<void> _printProcess(
      {required List<int> byteBuffer, required bool? byteLog, required bool? defaultPrintfun}) async {
    try {
      if (byteLog == true) {
        log("_printProcess====> ${Uint8List.fromList(byteBuffer)}");
      }
      if (selectedDevice == null) {
        print('$runtimeType - Device not selected');
        return Future<void>.value(null);
      }
      if (!_isConnected && selectedDevice != null) {
        await connect(selectedDevice!);
      }
      if (Platform.isAndroid) {
        // Determine if we should use writeBytes or defaultWriteBytes
        bool useWriteBytes = false;

        // Check if defaultPrintfun is explicitly set to false
        if (defaultPrintfun == false) {
          useWriteBytes = true;
        }

        // Auto-detect for GP1324d and other label printers
        PrinterType currentPrinterType = getPrinterType();
        if (currentPrinterType == PrinterType.gp1324d ||
            currentPrinterType == PrinterType.labelPrinter ||
            currentPrinterType == PrinterType.tspl ||
            currentPrinterType == PrinterType.zpl) {
          useWriteBytes = true;
          log("Auto-detected ${currentPrinterType} printer - using writeBytes");
        }

        if (useWriteBytes) {
          if (_bluetoothAndroid != null) {
            _bluetoothAndroid!.writeBytes(Uint8List.fromList(byteBuffer));
            log("Using writeBytes for ${currentPrinterType} printer (${detectedLanguage ?? 'unknown'})");
          }
        } else {
          if (_bluetoothAndroid != null) {
            _bluetoothAndroid!.defaultWriteBytes(Uint8List.fromList(byteBuffer));
            log("Using defaultWriteBytes for  receipt printer");
          }
        }
      } else if (Platform.isIOS) {
        final List<flutter_blue.BluetoothService> bluetoothServices =
            await _bluetoothDeviceIOS?.discoverServices() ?? <flutter_blue.BluetoothService>[];
        final flutter_blue.BluetoothService bluetoothService = bluetoothServices.firstWhere(
          (flutter_blue.BluetoothService service) => service.isPrimary,
        );
        final flutter_blue.BluetoothCharacteristic characteristic = bluetoothService.characteristics.firstWhere(
          (flutter_blue.BluetoothCharacteristic bluetoothCharacteristic) => bluetoothCharacteristic.properties.write,
        );
        await characteristic.write(byteBuffer, withoutResponse: true);
      }
    } on Exception catch (error) {
      print('$runtimeType - Error $error');
    }
  }

  /// Universal getbytes function that detects printer type and calls appropriate bytes function
  Future<List<int>> getbytes(Uint8List data,
      {required PaperSize paperSize,
      int customWidth = 0,
      int feedCount = 0,
      bool useCut = false,
      bool useRaster = false,
      bool isA4 = false,
      String? deviceName}) async {
    log("selectedDevice?.name==>${selectedDevice?.name}");
    // Get printer type from connected device or provided device name
    PrinterType detectedType = getPrinterType(deviceName: deviceName ?? selectedDevice?.name);

    log('getbytes: Using printer type: $detectedType for device: ${deviceName ?? selectedDevice?.name ?? "unknown"}');

    // Call appropriate bytes function based on detected printer type
    if (detectedType == PrinterType.escpos) {
      return await _getBytesESCPos(
        data,
        paperSize: paperSize,
        customWidth: customWidth,
        feedCount: feedCount,
        useCut: useCut,
        useRaster: useRaster,
        isA4: isA4,
      );
    } else {
      return await _getBytesOtherPrinterType(
        data,
        paperSize: paperSize,
        customWidth: customWidth,
        feedCount: feedCount,
        useCut: useCut,
        useRaster: useRaster,
        isA4: isA4,
        printerType: detectedType,
      );
    }
  }

  /// ESC/POS byte generation for android
  Future<List<int>> _getBytesESCPos(Uint8List data,
      {required PaperSize paperSize,
      int customWidth = 0,
      int feedCount = 0,
      bool useCut = false,
      bool useRaster = false,
      bool isA4 = false}) async {
    List<int> bytes = <int>[];
    final CapabilityProfile profile = await CapabilityProfile.load();
    final Generator generator = Generator(paperSize, profile);
    // img.Image? image = img.decodeImage(data);

    final img.Image resize = img.copyResize(
      img.decodeImage(data)!,
      width: customWidth > 0 ? customWidth : paperSize.width,
    );

    if (useRaster) {
      // bytes += generator.imageRaster(rgba32);
      bytes += generator.imageRaster(resize);
    } else {
      bytes += generator.image(resize);
    }
    if (feedCount > 0) {
      bytes += generator.feed(feedCount);
    }
    if (useCut) {
      bytes += generator.cut();
    }
    log("_getBytesESCPos====>${bytes.length}");
    return bytes;
  }

  ///Other printer type byte generation (GP1324d, TSPL, ZPL, etc.)
  Future<List<int>> _getBytesOtherPrinterType(Uint8List data,
      {required PaperSize paperSize,
      int customWidth = 0,
      int feedCount = 0,
      bool useCut = false,
      bool useRaster = false,
      bool isA4 = false,
      PrinterType printerType = PrinterType.escpos}) async {
    log('_getBytesOtherPrinterType: Processing for printer type: $printerType');

    // Handle GP1324d specifically with its own byte generation
    if (printerType == PrinterType.gp1324d) {
      log('🚀 Using GP1324d specific byte generation');
      List<int> gp1324dBytes = await _getGP1324dBytes(
        data,
        paperSize: paperSize,
        customWidth: customWidth,
        feedCount: feedCount,
        useCut: useCut,
      );
      log('✅ GP1324d bytes generated: ${gp1324dBytes.length} bytes');
      return gp1324dBytes;
    }

    // Handle other label printers with universal support (TSPL, ZPL, etc.)
    if (printerType == PrinterType.labelPrinter || printerType == PrinterType.tspl || printerType == PrinterType.zpl) {
      return _getLabelPrinterBytes(data,
          paperSize: paperSize, customWidth: customWidth, feedCount: feedCount, useCut: useCut);
    }

    // Fallback to ESC/POS for unsupported printer types
    print('_getBytesOtherPrinterType: Falling back to ESC/POS for unsupported type: $printerType');
    return await _getBytesESCPos(
      data,
      paperSize: paperSize,
      customWidth: customWidth,
      feedCount: feedCount,
      useCut: useCut,
      useRaster: useRaster,
      isA4: isA4,
    );
  }

  /// Universal label printer byte generation
  List<int> _getLabelPrinterBytes(Uint8List data,
      {required PaperSize paperSize, int customWidth = 0, int feedCount = 0, bool useCut = false}) {
    // Use universal label printer manager
    final config = labelConfig ??
        LabelPrinterConfig(
          language: detectedLanguage ?? LabelPrinterLanguage.tspl,
          labelWidth: paperSize == PaperSize.mm80 ? 80 : 58,
          labelHeight: 50,
          dpi: 203,
          useCutter: useCut,
        );

    return LabelPrinterManager.generatePrintCommands(
      imageData: data,
      config: config,
    );
  }

  /// Test universal label printer
  Future<void> testLabelPrinter() async {
    if (!_isConnected || selectedDevice == null) {
      print('Printer not connected');
      return;
    }

    try {
      // Auto-detect language if not set
      if (detectedLanguage == null && selectedDevice?.name != null) {
        detectedLanguage = LabelPrinterManager.detectPrinterLanguage(selectedDevice!.name ?? '');
      }

      final language = detectedLanguage ?? LabelPrinterLanguage.tspl;
      print('Testing label printer with language: $language');

      // Generate test commands for detected language
      final testCommands = LabelPrinterManager.generateTestCommands(language);

      if (_bluetoothAndroid != null) {
        _bluetoothAndroid!.writeBytes(Uint8List.fromList(testCommands));
      }
      print('Test commands sent for $language printer');
    } catch (e) {
      print('Error testing label printer: $e');
    }
  }

  /// Print label with automatic language detection
  Future<void> printLabel({
    required String content,
    String? barcode,
    LabelPrinterConfig? config,
    bool useImage = true,
  }) async {
    if (!_isConnected || selectedDevice == null) {
      print('Printer not connected');
      return;
    }

    try {
      List<int> commands = [];

      if (useImage) {
        // Convert content to image
        final Uint8List imageBytes = await contentToImage(
          content: content,
          duration: 0,
        );

        // Generate commands using detected or configured language
        final printerConfig = config ??
            labelConfig ??
            LabelPrinterConfig(
              language: detectedLanguage ?? LabelPrinterLanguage.tspl,
            );

        commands = LabelPrinterManager.generatePrintCommands(
          imageData: imageBytes,
          config: printerConfig,
          barcode: barcode,
        );
      } else {
        // Direct text printing
        final printerConfig = config ??
            labelConfig ??
            LabelPrinterConfig(
              language: detectedLanguage ?? LabelPrinterLanguage.tspl,
            );

        commands = LabelPrinterManager.generatePrintCommands(
          imageData: Uint8List(0),
          config: printerConfig,
          text: content,
          barcode: barcode,
        );
      }

      // Send commands to printer
      if (_bluetoothAndroid != null) {
        _bluetoothAndroid!.writeBytes(Uint8List.fromList(commands));
      }
      log('Label printed using ${detectedLanguage ?? "auto-detected"} language');
    } catch (e) {
      print('Error printing label: $e');
    }
  }

  /// Improved GP1324d specific byte generation with proper TSPL-like commands
  Future<List<int>> _getGP1324dBytes(Uint8List data,
      {required PaperSize paperSize, int customWidth = 0, int feedCount = 0, bool useCut = false}) async {
    log('🔧 Starting GP1324d byte generation...');
    List<int> bytes = <int>[];

    // GP1324d specific initialization sequence
    bytes += [0x1B, 0x40]; // Initialize printer (ESC @)
    bytes += [0x1B, 0x21, 0x00]; // Select font and reset formatting
    log('📝 Added initialization commands');

    // Set label size (GP1324d uses TSPL-like commands)
    int labelWidth = customWidth > 0 ? customWidth : (paperSize == PaperSize.mm80 ? 80 : 58);
    int labelHeight = 50; // Default label height

    // Convert mm to dots (GP1324d is 203 DPI)
    int widthDots = (labelWidth * 203 / 25.4).round();
    int heightDots = (labelHeight * 203 / 25.4).round();

    // SIZE command for GP1324d (similar to TSPL)
    String sizeCmd = 'SIZE $labelWidth mm, $labelHeight mm\r\n';
    bytes += sizeCmd.codeUnits;

    // GAP command - set gap between labels
    bytes += 'GAP 3 mm, 0 mm\r\n'.codeUnits;

    // SPEED and DENSITY settings
    bytes += 'SPEED 4\r\n'.codeUnits;
    bytes += 'DENSITY 8\r\n'.codeUnits;

    // DIRECTION (0 = normal, 1 = 90°, 2 = 180°, 3 = 270°)
    bytes += 'DIRECTION 0\r\n'.codeUnits;

    // Clear label buffer
    bytes += 'CLS\r\n'.codeUnits;

    // Process image
    final img.Image? decodedImage = img.decodeImage(data);
    if (decodedImage != null) {
      final img.Image resize = img.copyResize(
        decodedImage,
        width: widthDots,
      );

      // Convert image to GP1324d BITMAP format (TSPL-style)
      bytes += _convertImageToGP1324dBitmap(resize);
    }

    // Add feed lines if specified
    if (feedCount > 0) {
      for (int i = 0; i < feedCount; i++) {
        bytes += [0x0A]; // Line feed
      }
    }

    // Print command - GP1324d uses TSPL-like PRINT command
    bytes += 'PRINT 1,1\r\n'.codeUnits;

    log('🎯 GP1324d commands generated: ${bytes.length} total bytes');
    log('📤 Final GP1324d command sequence ready for transmission');
    return bytes;
  }

  /// Convert image to GP1324d BITMAP format (TSPL-style)
  List<int> _convertImageToGP1324dBitmap(img.Image image) {
    List<int> bytes = <int>[];

    int width = image.width;
    int height = image.height;
    int bytesPerRow = (width + 7) ~/ 8;

    // BITMAP command for GP1324d: BITMAP x,y,width,height,mode,data
    // x,y = position, width in bytes, height in dots, mode=1 for normal
    String bitmapCmd = 'BITMAP 10,10,$bytesPerRow,$height,1,';
    bytes += bitmapCmd.codeUnits;

    // Convert image to monochrome bitmap data
    for (int row = 0; row < height; row++) {
      for (int col = 0; col < bytesPerRow; col++) {
        int byte = 0;
        for (int bit = 0; bit < 8; bit++) {
          int pixelX = col * 8 + bit;
          if (pixelX < width) {
            final pixel = image.getPixel(pixelX, row);
            final luminance = img.getLuminance(pixel);
            // For GP1324d BITMAP: 1 = print dot (black), 0 = no print (white)
            // So we want to print when luminance is low (dark pixels)
            if (luminance < 128) {
              byte |= (0x80 >> bit);
            }
          }
        }
        bytes.add(byte);
      }
    }

    bytes += '\r\n'.codeUnits;
    return bytes;
  }

  /// Convert image to GP1324d compatible bitmap format (Legacy ESC/POS method)
  List<int> _convertImageToGP1324dFormat(img.Image image) {
    List<int> bytes = <int>[];

    // Use ESC * command for bit image printing
    // ESC * m nL nH d1...dk
    // where m = 0 (8-dot single density)
    //       nL, nH = number of dots (width)
    //       d1...dk = image data

    int width = image.width;
    int height = image.height;

    // Process image line by line
    for (int y = 0; y < height; y += 8) {
      // ESC * command
      bytes += [0x1B, 0x2A, 0x00]; // ESC * 0 (8-dot single density)

      // Width in dots (low byte, high byte)
      bytes += [width & 0xFF, (width >> 8) & 0xFF];

      // Convert 8 lines of pixels to bytes
      for (int x = 0; x < width; x++) {
        int byte = 0;
        for (int k = 0; k < 8; k++) {
          int pixelY = y + k;
          if (pixelY < height) {
            // Get pixel and convert to monochrome
            final pixel = image.getPixel(x, pixelY);
            final luminance = img.getLuminance(pixel);
            // Fixed: Invert logic for GP1324d - print bit when pixel is bright (white background)
            // This ensures black text on white background instead of white text on black background
            if (luminance >= 128) {
              byte |= (1 << (7 - k));
            }
          }
        }
        bytes.add(byte);
      }

      // Line feed after each row
      bytes += [0x0A];
    }

    return bytes;
  }

  /// Test function to verify GP1324d printer communication with improved commands
  Future<void> testGP1324dPrinter() async {
    if (!_isConnected || selectedDevice == null) {
      print('Printer not connected');
      return;
    }

    try {
      // Test 1: Initialize printer
      print('Testing GP1324d: Initializing printer...');
      List<int> initCommands = [];
      initCommands += [0x1B, 0x40]; // ESC @ - Initialize
      initCommands += 'SIZE 80 mm, 50 mm\r\n'.codeUnits;
      initCommands += 'GAP 3 mm, 0 mm\r\n'.codeUnits;
      initCommands += 'SPEED 4\r\n'.codeUnits;
      initCommands += 'DENSITY 8\r\n'.codeUnits;
      initCommands += 'DIRECTION 0\r\n'.codeUnits;
      initCommands += 'CLS\r\n'.codeUnits;

      if (_bluetoothAndroid != null) {
        _bluetoothAndroid!.writeBytes(Uint8List.fromList(initCommands));
      }
      await Future.delayed(Duration(milliseconds: 200));

      // Test 2: Print text using TEXT command
      print('Testing GP1324d: Sending TSPL text...');
      List<int> textCommands = [];
      textCommands += 'TEXT 10,10,"3",0,1,1,"GP1324D IMPROVED TEST"\r\n'.codeUnits;
      textCommands += 'TEXT 10,50,"2",0,1,1,"New TSPL Commands"\r\n'.codeUnits;
      textCommands += 'PRINT 1,1\r\n'.codeUnits;

      if (_bluetoothAndroid != null) {
        _bluetoothAndroid!.writeBytes(Uint8List.fromList(textCommands));
      }
      await Future.delayed(Duration(milliseconds: 200));

      // Test 3: Print barcode
      print('Testing GP1324d: Sending barcode...');
      List<int> barcodeCommands = [];
      barcodeCommands += 'CLS\r\n'.codeUnits;
      barcodeCommands += 'BARCODE 10,10,"128",100,1,0,2,2,"123456789"\r\n'.codeUnits;
      barcodeCommands += 'PRINT 1,1\r\n'.codeUnits;

      if (_bluetoothAndroid != null) {
        _bluetoothAndroid!.writeBytes(Uint8List.fromList(barcodeCommands));
      }

      print('GP1324d improved test commands sent successfully');
    } catch (e) {
      print('Error testing GP1324d: $e');
    }
  }

  /// Get printer type from connected Bluetooth device name
  PrinterType getPrinterType({String? deviceName}) {
    log("getPrinterType: deviceName=$deviceName, selectedDevice=${selectedDevice?.name}");
    String printerDeviceName = deviceName ?? selectedDevice?.name ?? '';
    return _detectPrinterTypeFromDeviceName(printerDeviceName);
  }

  /// Comprehensive printer type detection from Bluetooth device name
  PrinterType _detectPrinterTypeFromDeviceName(String deviceName) {
    log("_detectPrinterTypeFromDeviceName: Analyzing device name: $deviceName");
    if (deviceName.isEmpty) return PrinterType.escpos;

    final name = deviceName.toUpperCase();
    log('Detecting printer type for device: $deviceName');

    // GP1324d specific detection (exact match first)
    if (name.contains('GP1324D') ||
        name.contains('GP-1324D') ||
        name.contains('GP1324') ||
        name.contains('1324D-14C541') ||
        name.contains('1324D') ||
        name.contains('GP-1324')) {
      log('🎯 Detected GP1324d printer from device name: $deviceName');
      return PrinterType.gp1324d;
    }

    // TSC/TSPL printers
    if (name.contains('TSC') ||
        name.contains('TTP-') ||
        name.contains('TE200') ||
        name.contains('GODEX') ||
        name.contains('POSTEK') ||
        name.contains('ARGOX') ||
        name.contains('CITIZEN')) {
      print('Detected TSPL printer');
      return PrinterType.tspl;
    }

    // GPrinter family (excluding GP1324d)
    if (name.contains('GP') && !name.contains('GP1324')) {
      if (name.contains('GPRINTER') || name.contains('GP1124') || name.contains('GP2120')) {
        print('Detected GPrinter TSPL');
        return PrinterType.tspl;
      }
    }

    // Zebra ZPL printers
    if (name.contains('ZEBRA') ||
        name.contains('ZD') ||
        name.contains('GK') ||
        name.contains('GX') ||
        name.contains('ZT') ||
        name.contains('LP28') ||
        name.contains('TLP28')) {
      print('Detected ZPL printer');
      return PrinterType.zpl;
    }

    // Label printer general detection
    if (name.contains('LABEL') ||
        name.contains('QL') ||
        name.contains('RW') ||
        name.contains('P4T') ||
        name.contains('MOBILE') ||
        name.contains('EPL') ||
        name.contains('DATAMAX') ||
        name.contains('ONEIL') ||
        name.contains('DPL')) {
      print('Detected label printer');
      return PrinterType.labelPrinter;
    }

    // ESC/POS receipt printers
    if (name.contains('POS') ||
        name.contains('EPSON') ||
        name.contains('TM-') ||
        name.contains('RECEIPT') ||
        name.contains('THERMAL') ||
        name.contains('58MM') ||
        name.contains('80MM') ||
        name.contains('STAR') ||
        name.contains('TSP')) {
      print('Detected ESC/POS printer');
      return PrinterType.escpos;
    }

    // Default to ESC/POS for unknown printers
    print('Unknown printer type, defaulting to ESC/POS');
    return PrinterType.escpos;
  }

  /// Auto-detect printer type based on device name
  void _autoDetectPrinterType(String deviceName) {
    // Update printer type using new detection method
    printerType = _detectPrinterTypeFromDeviceName(deviceName);

    // Set up label printer configuration if needed
    if (printerType != PrinterType.escpos) {
      detectedLanguage = LabelPrinterManager.detectPrinterLanguage(deviceName);

      if (detectedLanguage != null && detectedLanguage != LabelPrinterLanguage.escposLabel) {
        labelConfig = LabelPrinterConfig(
          language: detectedLanguage!,
          labelWidth: 80,
          labelHeight: 50,
          dpi: 203,
        );
        print('Auto-detected label printer: $detectedLanguage');
      }
    }
  }

  /// Check if current printer is a label printer
  bool _isLabelPrinter() {
    return printerType == PrinterType.labelPrinter ||
        printerType == PrinterType.gp1324d ||
        printerType == PrinterType.tspl ||
        printerType == PrinterType.zpl;
  }

  /// Set printer type for proper command generation
  void setPrinterType(PrinterType type, {LabelPrinterConfig? config}) {
    printerType = type;
    if (config != null) {
      labelConfig = config;
    }
    print('Printer type set to: $type');
  }

  /// Set label printer configuration
  void setLabelPrinterConfig(LabelPrinterConfig config) {
    labelConfig = config;
    printerType = PrinterType.labelPrinter;
  }

  Future<void> paperCut() async {
    if (_bluetoothAndroid != null) {
      await _bluetoothAndroid!.paperCut();
    }
  }

  static Future<Uint8List> contentToImage({
    required String content,
    double duration = 0,
  }) async {
    final Map<String, dynamic> arguments = <String, dynamic>{
      'content': content,
      'duration': Platform.isIOS ? 2000 : duration,
    };
    Uint8List results = Uint8List.fromList(<int>[]);
    try {
      results = await _channel.invokeMethod('contentToImage', arguments) ?? Uint8List.fromList(<int>[]);
    } on Exception catch (e) {
      log('[method:contentToImage]: $e');
      throw Exception('Content conversion failed: $e');
    }
    return results;
  }
}
